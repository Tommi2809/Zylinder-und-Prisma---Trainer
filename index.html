<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Volumen & Oberfläche – Generator (Zylinder/Prisma)</title>
  <style>
    :root{
      --bg:#0b0c10;
      --panel:#12141c;
      --panel2:#171a24;
      --text:#e9eef6;
      --muted:#aeb8c6;
      --accent:#5aa9ff;
      --good:#67e08a;
      --bad:#ff6b6b;
      --warn:#ffd166;
      --line:#252a3a;
      --chip:#1c2130;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;

      /* Dropdown-Farben (dunkler) */
      --input-bg: #0f1621;
      --input-border: rgba(255,255,255,.18);
      --input-border-focus: rgba(90,169,255,.70);
      --input-text: #eaf2ff;
      --input-placeholder: rgba(234,242,255,.55);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 700px at 20% -10%, rgba(90,169,255,.22), transparent 60%),
                  radial-gradient(900px 600px at 90% 0%, rgba(103,224,138,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    header{
      padding:18px 18px 0 18px;
    }
    h1{
      font-size:18px;
      font-weight:650;
      margin:0 0 6px 0;
      letter-spacing:.2px;
    }
    .sub{
      color:var(--muted);
      font-size:13px;
      margin:0 0 12px 0;
      line-height:1.35;
    }
    .wrap{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
      padding: 14px 18px 18px 18px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--line);
      border-radius:14px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card h2{
      margin:0 0 10px 0;
      font-size:14px;
      letter-spacing:.2px;
      color:#dbe7ff;
      font-weight:650;
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin:10px 0 6px;
    }

    /* ===== Inputs / Dropdowns: dunkler + klare Option-Farben ===== */
    select, input[type="text"], input[type="number"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--input-text);
      outline:none;
      appearance: none;
    }
    input::placeholder{
      color: var(--input-placeholder);
    }
    select:focus, input:focus{
      border-color: var(--input-border-focus);
      box-shadow: 0 0 0 3px rgba(90,169,255,.14);
    }
    /* Dropdown-Liste (Optionen) */
    select option{
      background: var(--input-bg);
      color: var(--input-text);
    }
    /* Edge/Chrome: Selected Option */
    select option:checked{
      background: #152238;
      color: var(--input-text);
    }

    .row{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
    }
    button{
      border:1px solid var(--line);
      background: rgba(90,169,255,.12);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.2px;
    }
    button.secondary{ background: rgba(255,255,255,.05); }
    button:active{ transform: translateY(1px); }
    button:hover{ border-color: rgba(90,169,255,.55); }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.05);
      border:1px solid var(--line);
      font-size:12px;
      color:var(--muted);
      margin-right:8px;
      margin-top:8px;
    }
    .pill strong{ color:var(--text); font-weight:700; }
    .taskTitle{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px;
      margin-bottom:10px;
    }
    .taskTitle .chip{
      background: var(--chip);
      border:1px solid var(--line);
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:#dbe7ff;
    }
    .section{
      margin-top:10px;
      padding-top:10px;
      border-top:1px dashed rgba(255,255,255,.12);
    }
    .kv{
      display:grid;
      grid-template-columns:120px 1fr;
      gap:10px;
      font-size:13px;
      margin:6px 0;
    }
    .kv .k{ color:var(--muted); }
    .mono{ font-family:var(--mono); }
    .big{
      font-size:15px;
      font-weight:700;
    }
    .answerRow{
      display:grid;
      grid-template-columns: 1fr 140px;
      gap:10px;
      align-items:end;
      margin-top:8px;
    }
    .unitBox{
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
      color:var(--muted);
      font-size:12px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .status{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      font-size:13px;
      line-height:1.35;
    }
    .status.good{ border-color: rgba(103,224,138,.45); background: rgba(103,224,138,.08); }
    .status.bad{ border-color: rgba(255,107,107,.45); background: rgba(255,107,107,.08); }
    .status.warn{ border-color: rgba(255,209,102,.45); background: rgba(255,209,102,.07); }

    details{
      margin-top:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
      border-radius:14px;
      overflow:hidden;
    }
    summary{
      cursor:pointer;
      padding:12px 14px;
      font-weight:700;
      color:#dbe7ff;
      list-style:none;
    }
    summary::-webkit-details-marker{display:none;}
    .sol{
      padding: 0 14px 14px 14px;
      color: var(--text);
    }
    .step{
      margin-top:12px;
      padding:12px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.02);
    }
    .step .stHead{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom:8px;
    }
    .badge{
      width:26px;height:26px;border-radius:8px;
      background: rgba(90,169,255,.16);
      border:1px solid rgba(90,169,255,.35);
      display:flex;align-items:center;justify-content:center;
      font-weight:800;
    }
    .stTitle{ font-weight:800; }
    .stBody{
      color: var(--muted);
      font-size:13px;
      line-height:1.45;
      white-space:pre-wrap;
    }
    .smallNote{ color:var(--muted); font-size:12px; margin-top:8px; }
    .footerNote{ color:var(--muted); font-size:12px; margin-top:10px; }
    .toggleRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .toggle{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:12px;
      border:1px solid var(--line); background: rgba(255,255,255,.03);
      color: var(--muted); font-size:12px;
    }
    .toggle input{ transform: scale(1.1); }
  </style>
</head>

<body>
<header>
  <h1>Aufgabengenerator: Volumen & Oberfläche (Zylinder / Prisma)</h1>
  <p class="sub">
    Zufällige Aufgaben (cm/dm gemischt möglich). Gesucht rotiert (inkl. <span class="mono">r</span> beim Zylinder, auch aus <span class="mono">O</span> → quadratisch). Musterlösung im 6-Schritte-Stil mit <span class="mono">h_K</span>.
  </p>
</header>

<div class="wrap">
  <div class="card" id="settingsCard">
    <h2>Einstellungen</h2>

    <label for="shapeSel">Körper</label>
    <select id="shapeSel">
      <option value="cylinder">Zylinder</option>
      <option value="prism">Prisma</option>
    </select>

    <div id="baseWrap">
      <label for="baseSel">Grundfläche (Prisma)</label>
      <select id="baseSel">
        <option value="rtTriangle">Rechtwinkliges Dreieck</option>
        <option value="triangle">Allgemeines Dreieck</option>
        <option value="trapezoid">Trapez</option>
        <option value="parallelogram">Parallelogramm</option>
        <option value="rhombus">Raute</option>
        <option value="kite">Drachenviereck</option>
      </select>
    </div>

    <div class="row">
      <div>
        <label for="typeSel">Aufgabentyp</label>
        <select id="typeSel">
          <option value="V">Volumen</option>
          <option value="O">Oberfläche</option>
          <option value="mix">Zufällig</option>
        </select>
      </div>
      <div>
        <label for="difficultySel">Schwierigkeit</label>
        <select id="difficultySel">
          <option value="1">leicht</option>
          <option value="2" selected>mittel</option>
          <option value="3">schwer</option>
          <option value="mix">Zufällig</option>
        </select>
      </div>
    </div>

    <div class="toggleRow">
      <label class="toggle" title="Wenn aktiv, werden keine Aufgaben erzeugt, die eine quadratische Gleichung benötigen.">
        <input type="checkbox" id="noQuadratic" />
        Quadratische Gleichungen vermeiden
      </label>

      <label class="toggle" title="Wenn aktiv, werden bei Raute/Drachen nur Formeln verwendet, die direkt an die Standardflächenformeln anschließen.">
        <input type="checkbox" id="strictFormula" />
        Streng (Formelsammlung-nah)
      </label>
    </div>

    <div class="btns">
      <button id="newTaskBtn">Neue Aufgabe</button>
      <button class="secondary" id="regenBtn" title="Erzeugt eine neue Aufgabe mit gleicher Auswahl.">Neu würfeln</button>
    </div>

    <p class="footerNote">
      Rundung: Ergebnis auf <strong>2 Nachkommastellen</strong>. Hinweis, falls falsch gerundet.
    </p>
  </div>

  <div class="card" id="taskCard">
    <h2>Aufgabe</h2>

    <div id="taskArea">
      <div class="taskTitle">
        <span class="chip" id="chipShape">–</span>
        <span class="chip" id="chipType">–</span>
        <span class="chip" id="chipDiff">–</span>
      </div>

      <div class="section">
        <div class="kv">
          <div class="k">Gegeben:</div>
          <div class="v" id="givenList">–</div>
        </div>
        <div class="kv">
          <div class="k">Gesucht:</div>
          <div class="v big" id="unknownLine">–</div>
        </div>
      </div>

      <div class="section">
        <div class="answerRow">
          <div>
            <label for="ansInput">Dein Ergebnis</label>
            <input id="ansInput" type="text" inputmode="decimal" placeholder="z. B. 514,29" />
          </div>
          <div class="unitBox" id="ansUnit">–</div>
        </div>

        <div class="btns">
          <button id="checkBtn">Prüfen</button>
          <button class="secondary" id="showSolBtn">Musterlösung ein-/ausblenden</button>
        </div>

        <div id="statusBox" class="status" style="display:none"></div>

        <details id="solutionDetails">
          <summary>Musterlösung</summary>
          <div class="sol" id="solutionBody"></div>
        </details>
      </div>

      <div class="smallNote">
        Dezimaltrennzeichen: Komma oder Punkt erlaubt.
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   Utilities
========================= */
const rnd = (min, max) => Math.random() * (max - min) + min;
const rndi = (min, max) => Math.floor(rnd(min, max + 1));
const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

function fmt2(x){
  const s = (Math.round(x*100)/100).toFixed(2);
  return s.replace('.', ',');
}
function parseDE(s){
  if(!s) return NaN;
  s = String(s).trim().replace(/\s/g,'');
  s = s.replace(',', '.');
  const parts = s.split('.');
  if(parts.length > 2){
    s = parts.slice(0, -1).join('') + '.' + parts[parts.length-1];
  }
  const v = Number(s);
  return Number.isFinite(v) ? v : NaN;
}

function unitPow(u, p){
  return u + (p===1 ? '' : `<sup>${p}</sup>`);
}

function convLen(val, fromU, toU){
  if(fromU===toU) return val;
  if(fromU==='cm' && toU==='dm') return val/10;
  if(fromU==='dm' && toU==='cm') return val*10;
  throw new Error('unknown unit conversion');
}
function convArea(val, fromU, toU){
  if(fromU===toU) return val;
  if(fromU==='cm2' && toU==='dm2') return val/100;
  if(fromU==='dm2' && toU==='cm2') return val*100;
  throw new Error('unknown area conversion');
}
function convVol(val, fromU, toU){
  if(fromU===toU) return val;
  if(fromU==='cm3' && toU==='dm3') return val/1000;
  if(fromU==='dm3' && toU==='cm3') return val*1000;
  throw new Error('unknown volume conversion');
}

function solveQuadratic(a,b,c){
  if (Math.abs(a) < 1e-12){
    if (Math.abs(b) < 1e-12) return [];
    return [ -c/b ];
  }
  const D = b*b - 4*a*c;
  if(D < -1e-12) return [];
  const Ds = Math.sqrt(Math.max(0, D));
  return [ (-b + Ds)/(2*a), (-b - Ds)/(2*a) ];
}

/* =========================
   Task model
========================= */
let CURRENT = null;

/* =========================
   Units strategy
========================= */
function chooseUnitsMode(){
  // 0: all cm, 1: all dm, 2: mixed
  return pick([0,1,2]);
}
function chooseLenUnit(mode){
  if(mode===0) return 'cm';
  if(mode===1) return 'dm';
  return pick(['cm','dm']);
}
function chooseAreaUnit(mode){
  if(mode===0) return 'cm2';
  if(mode===1) return 'dm2';
  return pick(['cm2','dm2']);
}
function chooseVolUnit(mode){
  if(mode===0) return 'cm3';
  if(mode===1) return 'dm3';
  return pick(['cm3','dm3']);
}

/* =========================
   Base area/perimeter builders (Prisma)
   Always provide data so no Pythagoras/Trig needed.
========================= */
function base_rtTriangle(){
  const g = rndi(4, 16);
  const h = rndi(3, 14);
  // perimeter sides (independent)
  const a = rndi(4, 18);
  const b = rndi(4, 18);
  const c = rndi(4, 18);
  const G = g*h/2;
  const u = a+b+c;
  return {
    name: "Rechtwinkliges Dreieck",
    dims: {g,h,a,b,c},
    G, u,
    areaFormula: "G = (g · h) / 2",
    perFormula: "u = a + b + c"
  };
}
function base_triangle(){
  const g = rndi(5, 20);
  const h = rndi(4, 16);
  const a = rndi(5, 22);
  const b = rndi(5, 22);
  const c = rndi(5, 22);
  const G = g*h/2;
  const u = a+b+c;
  return {
    name: "Dreieck",
    dims: {g,h,a,b,c},
    G,u,
    areaFormula: "G = (g · h) / 2",
    perFormula: "u = a + b + c"
  };
}
function base_trapezoid(){
  const a = rndi(5, 22);
  const c = rndi(3, 18);
  const h = rndi(3, 14);
  const b = rndi(4, 20);
  const d = rndi(4, 20);
  const G = (a + c) * h / 2;
  const u = a + b + c + d;
  return {
    name:"Trapez",
    dims:{a,b,c,d,h},
    G,u,
    areaFormula: "G = ((a + c) · h) / 2",
    perFormula: "u = a + b + c + d"
  };
}
function base_parallelogram(){
  const g = rndi(6, 24);
  const h = rndi(3, 14);
  const a = g;
  const b = rndi(4, 22);
  const G = g*h;
  const u = 2*(a+b);
  return {
    name:"Parallelogramm",
    dims:{g,h,a,b},
    G,u,
    areaFormula: "G = g · h",
    perFormula: "u = 2 · (a + b)"
  };
}
function base_rhombus(){
  const a = rndi(5, 22);
  const ha = rndi(3, 14);
  const G = a*ha;
  const u = 4*a;
  return {
    name:"Raute",
    dims:{a,ha},
    G,u,
    areaFormula: "G = a · h_a",
    perFormula: "u = 4 · a"
  };
}
function base_kite(){
  const e = rndi(6, 26);
  const f = rndi(4, 22);
  const a = rndi(4, 20);
  const b = rndi(4, 20);
  const G = e*f/2;
  const u = 2*(a+b);
  return {
    name:"Drachenviereck",
    dims:{e,f,a,b},
    G,u,
    areaFormula: "G = (e · f) / 2",
    perFormula: "u = 2 · (a + b)"
  };
}

function makeBase(baseKey, strict){
  // strict: disable kite (falls gewünscht)
  if(strict && baseKey==='kite') return base_triangle();
  switch(baseKey){
    case 'rtTriangle': return base_rtTriangle();
    case 'triangle': return base_triangle();
    case 'trapezoid': return base_trapezoid();
    case 'parallelogram': return base_parallelogram();
    case 'rhombus': return base_rhombus();
    case 'kite': return base_kite();
    default: return base_triangle();
  }
}

/* =========================
   Cylinder generator
========================= */
function buildUnitStepCylinder({givenType, V_disp, O_disp, r_disp, h_disp}){
  const lines = [];
  if(givenType==='V' && V_disp){
    if(V_disp.unitBase==='dm'){
      lines.push(`${fmt2(V_disp.val)} dm³ = ${fmt2(convVol(V_disp.val, 'dm3', 'cm3'))} cm³`);
    } else lines.push(`V ist bereits in cm³ angegeben.`);
  }
  if(givenType==='O' && O_disp){
    if(O_disp.unitBase==='dm'){
      lines.push(`${fmt2(O_disp.val)} dm² = ${fmt2(convArea(O_disp.val, 'dm2', 'cm2'))} cm²`);
    } else lines.push(`O ist bereits in cm² angegeben.`);
  }
  if(r_disp){
    if(r_disp.unit==='dm'){
      lines.push(`${fmt2(r_disp.val)} dm = ${fmt2(convLen(r_disp.val,'dm','cm'))} cm`);
    } else lines.push(`r ist bereits in cm angegeben.`);
  }
  if(h_disp){
    if(h_disp.unit==='dm'){
      lines.push(`${fmt2(h_disp.val)} dm = ${fmt2(convLen(h_disp.val,'dm','cm'))} cm`);
    } else lines.push(`h_K ist bereits in cm angegeben.`);
  }
  return lines.join("\n");
}

function genCylinderTask(type, diff, unitsMode, noQuadratic){
  const lenU_r = chooseLenUnit(unitsMode);
  const lenU_h = chooseLenUnit(unitsMode);
  const volU = chooseVolUnit(unitsMode);
  const areaU = chooseAreaUnit(unitsMode);

  const r_cm = rndi(2, 12);
  const h_cm = rndi(4, 30);

  const G_cm2 = Math.PI * r_cm * r_cm;
  const V_cm3 = G_cm2 * h_cm;
  const O_cm2 = 2*G_cm2 + 2*Math.PI*r_cm*h_cm;

  // template selection
  const templates = [];
  if(type==='V'){
    templates.push('h_from_V_r');
    templates.push('r_from_V_h');
  } else {
    templates.push('h_from_O_r');
    templates.push(noQuadratic ? 'h_from_O_r' : 'r_from_O_h'); // allow r_from_O_h if not blocked
  }
  let template = pick(templates);
  if(noQuadratic && template==='r_from_O_h') template = 'h_from_O_r';

  // display helpers
  const showLen = (val_cm, unit) => ({val: convLen(val_cm,'cm',unit), unit});
  const showVol = (val_cm3, unit3) => ({
    val: convVol(val_cm3,'cm3',unit3),
    unit3,
    unitBase: unit3==='cm3' ? 'cm' : 'dm'
  });
  const showArea = (val_cm2, unit2) => ({
    val: convArea(val_cm2,'cm2',unit2),
    unit2,
    unitBase: unit2==='cm2' ? 'cm' : 'dm'
  });

  const V_disp = showVol(V_cm3, volU);
  const O_disp = showArea(O_cm2, areaU);
  const r_disp = showLen(r_cm, lenU_r);
  const h_disp = showLen(h_cm, lenU_h);

  const needConv = () => (unitsMode===2) || (lenU_r==='dm') || (lenU_h==='dm') || (volU==='dm3') || (areaU==='dm2');

  const given = [];
  let unknown = null;
  let ansValue = NaN;
  let ansUnitHtml = '';
  const steps = [];

  if(template==='h_from_V_r'){
    given.push({sym:'V', text:`V = ${fmt2(V_disp.val)} ${unitPow(V_disp.unitBase,3)}`});
    given.push({sym:'r', text:`r = ${fmt2(r_disp.val)} ${r_disp.unit}`});
    unknown = {text:'h_K', unitHtml: lenU_h};

    const h_calc_cm = V_cm3 / (Math.PI*r_cm*r_cm);
    ansValue = convLen(h_calc_cm,'cm',lenU_h);
    ansUnitHtml = lenU_h;

    const s1 = needConv() ? buildUnitStepCylinder({givenType:'V', V_disp, r_disp, h_disp:null}) : "Alle Angaben sind bereits passend.";
    const s2 = `Skizze (schematisch): Zylinder mit Radius r und Körperhöhe h_K.\nGegeben: V, r\nGesucht: h_K`;
    const s3 = `Formeln:\nG = π · r²\nV = G · h_K`;
    const s4 = `Einsetzen:\nV = (π · r²) · h_K`;
    const s5 = `Umstellen:\nh_K = V / (π · r²)\n\nBerechnen (in cm):\nh_K ≈ ${fmt2(h_calc_cm)} cm\n⇒ h_K ≈ ${fmt2(ansValue)} ${lenU_h}`;
    const s6 = `Antwort: h_K ≈ ${fmt2(ansValue)} ${lenU_h}.`;

    steps.push(
      {title:"Einheiten angleichen", body:s1},
      {title:"Skizze / Gegeben / Gesucht", body:s2},
      {title:"Formeln notieren", body:s3},
      {title:"Einsetzen", body:s4},
      {title:"Umstellen und berechnen", body:s5},
      {title:"Antwortsatz", body:s6}
    );
  }

  if(template==='r_from_V_h'){
    given.push({sym:'V', text:`V = ${fmt2(V_disp.val)} ${unitPow(V_disp.unitBase,3)}`});
    given.push({sym:'h_K', text:`h_K = ${fmt2(h_disp.val)} ${h_disp.unit}`});
    unknown = {text:'r', unitHtml: lenU_r};

    const r_calc_cm = Math.sqrt(V_cm3/(Math.PI*h_cm));
    ansValue = convLen(r_calc_cm,'cm',lenU_r);
    ansUnitHtml = lenU_r;

    const s1 = needConv() ? buildUnitStepCylinder({givenType:'V', V_disp, r_disp:null, h_disp}) : "Alle Angaben sind bereits passend.";
    const s2 = `Skizze (schematisch): Zylinder mit Radius r und Körperhöhe h_K.\nGegeben: V, h_K\nGesucht: r`;
    const s3 = `Formeln:\nG = π · r²\nV = G · h_K`;
    const s4 = `Einsetzen:\nV = (π · r²) · h_K`;
    const s5 = `Umstellen:\nr² = V / (π · h_K)\nr = √( V / (π · h_K) )\n\nBerechnen (in cm):\nr ≈ ${fmt2(r_calc_cm)} cm\n⇒ r ≈ ${fmt2(ansValue)} ${lenU_r}`;
    const s6 = `Antwort: r ≈ ${fmt2(ansValue)} ${lenU_r}.`;

    steps.push(
      {title:"Einheiten angleichen", body:s1},
      {title:"Skizze / Gegeben / Gesucht", body:s2},
      {title:"Formeln notieren", body:s3},
      {title:"Einsetzen", body:s4},
      {title:"Umstellen und berechnen", body:s5},
      {title:"Antwortsatz", body:s6}
    );
  }

  if(template==='h_from_O_r'){
    given.push({sym:'O', text:`O = ${fmt2(O_disp.val)} ${unitPow(O_disp.unitBase,2)}`});
    given.push({sym:'r', text:`r = ${fmt2(r_disp.val)} ${r_disp.unit}`});
    unknown = {text:'h_K', unitHtml: lenU_h};

    const h_calc_cm = (O_cm2 - 2*Math.PI*r_cm*r_cm) / (2*Math.PI*r_cm);
    ansValue = convLen(h_calc_cm,'cm',lenU_h);
    ansUnitHtml = lenU_h;

    const s1 = needConv() ? buildUnitStepCylinder({givenType:'O', O_disp, r_disp, h_disp:null}) : "Alle Angaben sind bereits passend.";
    const s2 = `Skizze (schematisch): Zylinder mit Radius r und Körperhöhe h_K.\nGegeben: O, r\nGesucht: h_K`;
    const s3 = `Formeln:\nG = π · r²\nu = 2π · r\nM = u · h_K\nO = 2G + M`;
    const s4 = `Einsetzen:\nO = 2(π · r²) + (2π · r) · h_K`;
    const s5 = `Umstellen:\nh_K = (O - 2πr²) / (2πr)\n\nBerechnen (in cm):\nh_K ≈ ${fmt2(h_calc_cm)} cm\n⇒ h_K ≈ ${fmt2(ansValue)} ${lenU_h}`;
    const s6 = `Antwort: h_K ≈ ${fmt2(ansValue)} ${lenU_h}.`;

    steps.push(
      {title:"Einheiten angleichen", body:s1},
      {title:"Skizze / Gegeben / Gesucht", body:s2},
      {title:"Formeln notieren", body:s3},
      {title:"Einsetzen", body:s4},
      {title:"Umstellen und berechnen", body:s5},
      {title:"Antwortsatz", body:s6}
    );
  }

  if(template==='r_from_O_h'){
    given.push({sym:'O', text:`O = ${fmt2(O_disp.val)} ${unitPow(O_disp.unitBase,2)}`});
    given.push({sym:'h_K', text:`h_K = ${fmt2(h_disp.val)} ${h_disp.unit}`});
    unknown = {text:'r', unitHtml: lenU_r};

    // 2π r² + 2π h r - O = 0
    const A = 2*Math.PI;
    const B = 2*Math.PI*h_cm;
    const C = -O_cm2;
    const roots = solveQuadratic(A,B,C).filter(x=>x>0);
    const r_calc_cm = roots.length ? Math.max(...roots) : NaN;

    ansValue = convLen(r_calc_cm,'cm',lenU_r);
    ansUnitHtml = lenU_r;

    const s1 = needConv() ? buildUnitStepCylinder({givenType:'O', O_disp, r_disp:null, h_disp}) : "Alle Angaben sind bereits passend.";
    const s2 = `Skizze (schematisch): Zylinder mit Radius r und Körperhöhe h_K.\nGegeben: O, h_K\nGesucht: r`;
    const s3 = `Formeln:\nG = π · r²\nu = 2π · r\nM = u · h_K\nO = 2G + M`;
    const s4 = `Einsetzen:\nO = 2(π · r²) + (2π · r) · h_K\n⇒ 2πr² + 2πh_K r - O = 0`;
    const s5 = `Quadratische Gleichung lösen (r>0):\n(2π)r² + (2πh_K)r - O = 0\nr = ( -b + √(b² - 4ac) ) / (2a)\n\nBerechnen (in cm):\nr ≈ ${fmt2(r_calc_cm)} cm\n⇒ r ≈ ${fmt2(ansValue)} ${lenU_r}`;
    const s6 = `Antwort: r ≈ ${fmt2(ansValue)} ${lenU_r}.`;

    steps.push(
      {title:"Einheiten angleichen", body:s1},
      {title:"Skizze / Gegeben / Gesucht", body:s2},
      {title:"Formeln notieren", body:s3},
      {title:"Einsetzen", body:s4},
      {title:"Umstellen und berechnen", body:s5},
      {title:"Antwortsatz", body:s6}
    );
  }

  return {
    meta: {shape:'cylinder', type, difficulty:diff, unitsMode, noQuadratic},
    given, unknown,
    answer: {value: ansValue, unitHtml: ansUnitHtml},
    exactValue: ansValue,
    solutionSteps: steps,
    rounded2: Math.round(ansValue*100)/100
  };
}

/* =========================
   Prism generator
========================= */
function buildUnitStepPrism({givenType, V_disp, O_disp, dimDisplay, lenU_hK}){
  const lines = [];
  if(givenType==='V' && V_disp){
    if(V_disp.unitBase==='dm') lines.push(`${fmt2(V_disp.val)} dm³ = ${fmt2(convVol(V_disp.val,'dm3','cm3'))} cm³`);
    else lines.push(`V ist bereits in cm³ angegeben.`);
  }
  if(givenType==='O' && O_disp){
    if(O_disp.unitBase==='dm') lines.push(`${fmt2(O_disp.val)} dm² = ${fmt2(convArea(O_disp.val,'dm2','cm2'))} cm²`);
    else lines.push(`O ist bereits in cm² angegeben.`);
  }
  const anyDm = Object.values(dimDisplay).some(d => d.unit==='dm');
  if(anyDm){
    for(const [sym,d] of Object.entries(dimDisplay)){
      if(d.unit==='dm') lines.push(`${sym}: ${fmt2(d.val)} dm = ${fmt2(convLen(d.val,'dm','cm'))} cm`);
    }
  } else lines.push(`Alle Grundflächenmaße sind bereits in cm angegeben.`);
  if(lenU_hK==='dm') lines.push(`h_K (falls gegeben) dm → cm umrechnen.`);
  else lines.push(`h_K ist bereits in cm angegeben (falls gegeben).`);
  return lines.join("\n");
}

function dimsNeededForArea(baseKey){
  switch(baseKey){
    case 'rtTriangle':
    case 'triangle': return ['g','h'];
    case 'trapezoid': return ['a','c','h'];
    case 'parallelogram': return ['g','h'];
    case 'rhombus': return ['a','ha'];
    case 'kite': return ['e','f'];
    default: return [];
  }
}
function dimsNeededForPerimeter(baseKey){
  switch(baseKey){
    case 'rtTriangle':
    case 'triangle': return ['a','b','c'];
    case 'trapezoid': return ['a','b','c','d'];
    case 'parallelogram': return ['a','b'];
    case 'rhombus': return ['a'];
    case 'kite': return ['a','b'];
    default: return [];
  }
}

function measureOptionsForBase(baseKey){
  const opts = [];
  if(baseKey==='triangle' || baseKey==='rtTriangle'){
    opts.push({sym:'h', label:'h (Dreieckshöhe)'});
    opts.push({sym:'g', label:'g (Grundseite)'});
  }
  if(baseKey==='trapezoid'){
    opts.push({sym:'h', label:'h (Trapezhöhe)'});
    opts.push({sym:'a', label:'a (parallele Seite)'});
    opts.push({sym:'c', label:'c (parallele Seite)'});
  }
  if(baseKey==='parallelogram'){
    opts.push({sym:'h', label:'h (Höhe)'});
    opts.push({sym:'g', label:'g (Grundseite)'});
  }
  if(baseKey==='rhombus'){
    opts.push({sym:'ha', label:'h_a (Höhe zur Seite a)'});
  }
  if(baseKey==='kite'){
    opts.push({sym:'e', label:'e (Diagonale)'});
    opts.push({sym:'f', label:'f (Diagonale)'});
  }
  return opts;
}

function sideOptionsForBase(baseKey){
  const opts = [];
  if(baseKey==='trapezoid'){
    opts.push({sym:'d', label:'d (Seitenlänge)'});
  }
  if(baseKey==='triangle' || baseKey==='rtTriangle'){
    opts.push({sym:'c', label:'c (Seitenlänge)'});
  }
  if(baseKey==='parallelogram'){
    opts.push({sym:'b', label:'b (Seitenlänge)'});
  }
  if(baseKey==='rhombus'){
    opts.push({sym:'a', label:'a (Seitenlänge)'});
  }
  if(baseKey==='kite'){
    opts.push({sym:'b', label:'b (Seitenlänge)'});
  }
  return opts;
}

function genPrismTask(baseKey, type, diff, unitsMode, strictFormula){
  const base = makeBase(baseKey, strictFormula);

  const hK_cm = rndi(4, 28);
  const V_cm3 = base.G * hK_cm;
  const O_cm2 = 2*base.G + base.u * hK_cm;

  const lenU_hK = chooseLenUnit(unitsMode);
  const volU = chooseVolUnit(unitsMode);
  const areaU = chooseAreaUnit(unitsMode);

  const baseLenU = chooseLenUnit(unitsMode);

  const dimDisplay = {};
  for(const [k,v] of Object.entries(base.dims)){
    dimDisplay[k] = {unit: baseLenU, val: convLen(v,'cm',baseLenU)};
  }
  const hK_disp = {unit: lenU_hK, val: convLen(hK_cm,'cm',lenU_hK)};

  const V_disp = {val: convVol(V_cm3,'cm3',volU), unit3: volU, unitBase: volU==='cm3'?'cm':'dm'};
  const O_disp = {val: convArea(O_cm2,'cm2',areaU), unit2: areaU, unitBase: areaU==='cm2'?'cm':'dm'};

  const templates = [];
  if(type==='V'){
    templates.push('hK_from_V');
    if(diff>=2) templates.push('oneMeasure_from_V');
  } else {
    templates.push('hK_from_O');
    if(diff>=3) templates.push('side_from_O');
  }
  let template = pick(templates);

  if(template==='side_from_O' && sideOptionsForBase(baseKey).length===0) template='hK_from_O';
  if(template==='oneMeasure_from_V' && measureOptionsForBase(baseKey).length===0) template='hK_from_V';

  const needConv = () => (unitsMode===2) || (baseLenU==='dm') || (lenU_hK==='dm') || (volU==='dm3') || (areaU==='dm2');

  const given = [];
  let unknown = null;
  let ansValue = NaN;
  let ansUnitHtml = '';
  const steps = [];

  const baseName = base.name;

  if(template==='hK_from_V'){
    given.push({text:`V = ${fmt2(V_disp.val)} ${unitPow(V_disp.unitBase,3)}`});
    for(const sym of dimsNeededForArea(baseKey)){
      const d = dimDisplay[sym];
      given.push({text:`${sym} = ${fmt2(d.val)} ${d.unit}`});
    }
    unknown = {text:'h_K', unitHtml: lenU_hK};

    const hK_calc_cm = V_cm3 / base.G;
    ansValue = convLen(hK_calc_cm,'cm',lenU_hK);
    ansUnitHtml = lenU_hK;

    const s1 = needConv() ? buildUnitStepPrism({givenType:'V', V_disp, dimDisplay, lenU_hK}) : "Alle Angaben sind bereits passend.";
    const s2 = `Skizze (schematisch): Prisma mit Grundfläche (${baseName}) und Körperhöhe h_K.\nGegeben: V und Grundflächenmaße\nGesucht: h_K`;
    const s3 = `Formeln:\n${base.areaFormula}\nV = G · h_K`;
    const s4 = `Einsetzen:\nV = G · h_K`;
    const s5 = `Umstellen:\nh_K = V / G\nG = ${fmt2(base.G)} cm²\nh_K ≈ ${fmt2(hK_calc_cm)} cm\n⇒ h_K ≈ ${fmt2(ansValue)} ${lenU_hK}`;
    const s6 = `Antwort: h_K ≈ ${fmt2(ansValue)} ${lenU_hK}.`;

    steps.push(
      {title:"Einheiten angleichen", body:s1},
      {title:"Skizze / Gegeben / Gesucht", body:s2},
      {title:"Formeln notieren", body:s3},
      {title:"Einsetzen", body:s4},
      {title:"Umstellen und berechnen", body:s5},
      {title:"Antwortsatz", body:s6}
    );
  }

  if(template==='hK_from_O'){
    given.push({text:`O = ${fmt2(O_disp.val)} ${unitPow(O_disp.unitBase,2)}`});
    const needDims = new Set([...dimsNeededForArea(baseKey), ...dimsNeededForPerimeter(baseKey)]);
    for(const sym of needDims){
      const d = dimDisplay[sym];
      given.push({text:`${sym} = ${fmt2(d.val)} ${d.unit}`});
    }
    unknown = {text:'h_K', unitHtml: lenU_hK};

    const hK_calc_cm = (O_cm2 - 2*base.G) / base.u;
    ansValue = convLen(hK_calc_cm,'cm',lenU_hK);
    ansUnitHtml = lenU_hK;

    const s1 = needConv() ? buildUnitStepPrism({givenType:'O', O_disp, dimDisplay, lenU_hK}) : "Alle Angaben sind bereits passend.";
    const s2 = `Skizze (schematisch): Prisma mit Grundfläche (${baseName}) und Körperhöhe h_K.\nGegeben: O und Grundflächenmaße\nGesucht: h_K`;
    const s3 = `Formeln:\n${base.areaFormula}\n${base.perFormula}\nM = u · h_K\nO = 2G + M`;
    const s4 = `Einsetzen:\nO = 2G + u · h_K`;
    const s5 = `Umstellen:\nh_K = (O - 2G) / u\nG = ${fmt2(base.G)} cm²\nu = ${fmt2(base.u)} cm\nh_K ≈ ${fmt2(hK_calc_cm)} cm\n⇒ h_K ≈ ${fmt2(ansValue)} ${lenU_hK}`;
    const s6 = `Antwort: h_K ≈ ${fmt2(ansValue)} ${lenU_hK}.`;

    steps.push(
      {title:"Einheiten angleichen", body:s1},
      {title:"Skizze / Gegeben / Gesucht", body:s2},
      {title:"Formeln notieren", body:s3},
      {title:"Einsetzen", body:s4},
      {title:"Umstellen und berechnen", body:s5},
      {title:"Antwortsatz", body:s6}
    );
  }

  if(template==='oneMeasure_from_V'){
    const opts = measureOptionsForBase(baseKey);
    const target = pick(opts);

    given.push({text:`V = ${fmt2(V_disp.val)} ${unitPow(V_disp.unitBase,3)}`});
    given.push({text:`h_K = ${fmt2(hK_disp.val)} ${hK_disp.unit}`});

    for(const sym of dimsNeededForArea(baseKey)){
      if(sym===target.sym) continue;
      const d = dimDisplay[sym];
      given.push({text:`${sym} = ${fmt2(d.val)} ${d.unit}`});
    }
    unknown = {text: target.label, unitHtml: baseLenU};

    const G_from_V = V_cm3 / hK_cm;
    let x_cm = NaN;

    if(baseKey==='triangle' || baseKey==='rtTriangle'){
      const g = base.dims.g, h = base.dims.h;
      if(target.sym==='h') x_cm = 2*G_from_V / g;
      if(target.sym==='g') x_cm = 2*G_from_V / h;
    } else if(baseKey==='trapezoid'){
      const a = base.dims.a, c = base.dims.c, h = base.dims.h;
      if(target.sym==='h') x_cm = 2*G_from_V / (a+c);
      if(target.sym==='a') x_cm = (2*G_from_V / h) - c;
      if(target.sym==='c') x_cm = (2*G_from_V / h) - a;
    } else if(baseKey==='parallelogram'){
      const g = base.dims.g, h = base.dims.h;
      if(target.sym==='h') x_cm = G_from_V / g;
      if(target.sym==='g') x_cm = G_from_V / h;
    } else if(baseKey==='rhombus'){
      const a = base.dims.a;
      if(target.sym==='ha') x_cm = G_from_V / a;
    } else if(baseKey==='kite'){
      const e = base.dims.e, f = base.dims.f;
      if(target.sym==='e') x_cm = 2*G_from_V / f;
      if(target.sym==='f') x_cm = 2*G_from_V / e;
    }

    ansValue = convLen(x_cm,'cm',baseLenU);
    ansUnitHtml = baseLenU;

    const s1 = needConv() ? buildUnitStepPrism({givenType:'V', V_disp, dimDisplay, lenU_hK}) : "Alle Angaben sind bereits passend.";
    const s2 = `Skizze (schematisch): Prisma mit Grundfläche (${baseName}) und Körperhöhe h_K.\nGegeben: V, h_K und Grundflächenmaße (bis auf ${target.sym})\nGesucht: ${target.label}`;
    const s3 = `Formeln:\nV = G · h_K\n${base.areaFormula}`;
    const s4 = `Zwischenrechnung:\nG = V / h_K\nG = ${fmt2(G_from_V)} cm²`;
    const s5 = `Umstellen nach ${target.sym} und berechnen:\n≈ ${fmt2(x_cm)} cm\n⇒ ≈ ${fmt2(ansValue)} ${baseLenU}`;
    const s6 = `Antwort: ${target.label} ≈ ${fmt2(ansValue)} ${baseLenU}.`;

    steps.push(
      {title:"Einheiten angleichen", body:s1},
      {title:"Skizze / Gegeben / Gesucht", body:s2},
      {title:"Formeln notieren", body:s3},
      {title:"Zwischenrechnung", body:s4},
      {title:"Umstellen und berechnen", body:s5},
      {title:"Antwortsatz", body:s6}
    );
  }

  if(template==='side_from_O'){
    const opts = sideOptionsForBase(baseKey);
    const target = pick(opts);

    given.push({text:`O = ${fmt2(O_disp.val)} ${unitPow(O_disp.unitBase,2)}`});
    given.push({text:`h_K = ${fmt2(hK_disp.val)} ${hK_disp.unit}`});

    // give all area dims
    for(const sym of dimsNeededForArea(baseKey)){
      const d = dimDisplay[sym];
      given.push({text:`${sym} = ${fmt2(d.val)} ${d.unit}`});
    }
    // give all perim dims except target
    for(const sym of dimsNeededForPerimeter(baseKey)){
      if(sym===target.sym) continue;
      const d = dimDisplay[sym];
      given.push({text:`${sym} = ${fmt2(d.val)} ${d.unit}`});
    }

    unknown = {text: target.label, unitHtml: baseLenU};

    const u_from_O = (O_cm2 - 2*base.G) / hK_cm; // cm
    let x_cm = NaN;
    if(baseKey==='trapezoid' && target.sym==='d'){
      x_cm = u_from_O - (base.dims.a + base.dims.b + base.dims.c);
    } else if((baseKey==='triangle' || baseKey==='rtTriangle') && target.sym==='c'){
      x_cm = u_from_O - (base.dims.a + base.dims.b);
    } else if(baseKey==='parallelogram' && target.sym==='b'){
      x_cm = (u_from_O/2) - base.dims.a;
    } else if(baseKey==='rhombus' && target.sym==='a'){
      x_cm = u_from_O/4;
    } else if(baseKey==='kite' && target.sym==='b'){
      x_cm = (u_from_O/2) - base.dims.a;
    }

    ansValue = convLen(x_cm,'cm',baseLenU);
    ansUnitHtml = baseLenU;

    const s1 = needConv() ? buildUnitStepPrism({givenType:'O', O_disp, dimDisplay, lenU_hK}) : "Alle Angaben sind bereits passend.";
    const s2 = `Skizze (schematisch): Prisma mit Grundfläche (${baseName}) und Körperhöhe h_K.\nGegeben: O, h_K und Grundflächenmaße (bis auf ${target.sym})\nGesucht: ${target.label}`;
    const s3 = `Formeln:\n${base.areaFormula}\n${base.perFormula}\nO = 2G + u · h_K`;
    const s4 = `Zwischenrechnung:\nu = (O - 2G) / h_K\nu ≈ ${fmt2(u_from_O)} cm`;
    const s5 = `Umstellen nach ${target.sym} und berechnen:\n≈ ${fmt2(x_cm)} cm\n⇒ ≈ ${fmt2(ansValue)} ${baseLenU}`;
    const s6 = `Antwort: ${target.label} ≈ ${fmt2(ansValue)} ${baseLenU}.`;

    steps.push(
      {title:"Einheiten angleichen", body:s1},
      {title:"Skizze / Gegeben / Gesucht", body:s2},
      {title:"Formeln notieren", body:s3},
      {title:"Zwischenrechnung", body:s4},
      {title:"Umstellen und berechnen", body:s5},
      {title:"Antwortsatz", body:s6}
    );
  }

  return {
    meta: {shape:'prism', base:baseKey, baseName, type, difficulty:diff, unitsMode, strictFormula},
    given, unknown,
    answer: {value: ansValue, unitHtml: ansUnitHtml},
    exactValue: ansValue,
    solutionSteps: steps,
    rounded2: Math.round(ansValue*100)/100
  };
}

/* =========================
   Orchestrator & Rendering
========================= */
function generateTaskFromUI(){
  const shape = document.getElementById('shapeSel').value;
  const baseKey = document.getElementById('baseSel').value;
  const typeSel = document.getElementById('typeSel').value;
  const diffSel = document.getElementById('difficultySel').value;
  const noQuadratic = document.getElementById('noQuadratic').checked;
  const strictFormula = document.getElementById('strictFormula').checked;

  const type = (typeSel==='mix') ? pick(['V','O']) : typeSel;
  const diff = (diffSel==='mix') ? pick([1,2,3]) : Number(diffSel);
  const unitsMode = chooseUnitsMode();

  let task = null;
  if(shape==='cylinder'){
    task = genCylinderTask(type, diff, unitsMode, noQuadratic);
  }else{
    task = genPrismTask(baseKey, type, diff, unitsMode, strictFormula);
  }
  CURRENT = task;
  renderTask(task);
}

function escapeHtml(str){
  return String(str)
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;');
}

function renderSolutionSteps(steps){
  return steps.map((s, idx) => `
    <div class="step">
      <div class="stHead">
        <div class="badge">${idx+1}</div>
        <div class="stTitle">${escapeHtml(s.title)}</div>
      </div>
      <div class="stBody mono">${escapeHtml(s.body)}</div>
    </div>
  `).join("");
}

function renderTask(task){
  const chipShape = document.getElementById('chipShape');
  const chipType  = document.getElementById('chipType');
  const chipDiff  = document.getElementById('chipDiff');

  chipShape.textContent = (task.meta.shape==='cylinder')
    ? 'Zylinder'
    : ('Prisma – ' + (task.meta.baseName || ''));

  chipType.textContent = (task.meta.type==='V') ? 'Aufgabentyp: Volumen' : 'Aufgabentyp: Oberfläche';
  chipDiff.textContent = 'Schwierigkeit: ' + ({1:'leicht',2:'mittel',3:'schwer'}[task.meta.difficulty] || '–');

  const givenList = document.getElementById('givenList');
  givenList.innerHTML = task.given.map(g => `<div class="mono">${escapeHtml(g.text)}</div>`).join("");

  const unknownLine = document.getElementById('unknownLine');
  unknownLine.innerHTML = `<span class="mono">${escapeHtml(task.unknown.text)}</span>`;

  const ansUnit = document.getElementById('ansUnit');
  ansUnit.innerHTML = task.answer.unitHtml;

  // clear input/status
  document.getElementById('ansInput').value = '';
  const status = document.getElementById('statusBox');
  status.style.display='none';
  status.className='status';
  status.textContent='';

  // render solution
  const details = document.getElementById('solutionDetails');
  details.open = false;
  document.getElementById('solutionBody').innerHTML = renderSolutionSteps(task.solutionSteps);
}

/* =========================
   Checking logic (2 decimals + rounding hint)
========================= */
function hasTwoDecimals(raw){
  if(!raw) return false;
  raw = String(raw).trim();
  const m = raw.match(/[,.](\d+)/);
  if(!m) return false;
  return m[1].length === 2;
}

function checkAnswer(){
  if(!CURRENT) return;
  const raw = document.getElementById('ansInput').value;
  const y = parseDE(raw);
  const box = document.getElementById('statusBox');
  box.style.display='block';

  if(!Number.isFinite(y)){
    box.className = 'status bad';
    box.textContent = 'Bitte eine Zahl eingeben (Komma oder Punkt erlaubt).';
    return;
  }

  const x = CURRENT.exactValue;        // exact in target unit
  const x2 = Math.round(x*100)/100;    // expected rounded
  const eps = 0.005 + 1e-12;

  const yHas2Dec = hasTwoDecimals(raw);
  const good = Math.abs(y - x2) <= eps;

  if(good){
    box.className = 'status good';
    box.textContent = `Richtig. Erwartet: ${fmt2(x2)} ${CURRENT.answer.unitHtml}`;
    return;
  }

  const closeToExact = Math.abs(y - x) <= eps;
  if(closeToExact && Math.abs(x - x2) > 1e-12){
    box.className = 'status warn';
    box.textContent = `Fast. Dein Wert ist nahe am exakten Ergebnis, aber nicht korrekt auf 2 Nachkommastellen gerundet. Erwartet: ${fmt2(x2)} ${CURRENT.answer.unitHtml}`;
    return;
  }

  if(!yHas2Dec && Math.abs(y - x2) <= 0.02){
    box.className = 'status warn';
    box.textContent = `Bitte auf 2 Nachkommastellen runden. Erwartet: ${fmt2(x2)} ${CURRENT.answer.unitHtml}`;
    return;
  }

  box.className = 'status bad';
  box.textContent = `Leider falsch. Erwartet: ${fmt2(x2)} ${CURRENT.answer.unitHtml}`;
}

/* =========================
   UI wiring
========================= */
function syncBaseVisibility(){
  const shape = document.getElementById('shapeSel').value;
  document.getElementById('baseWrap').style.display = (shape==='prism') ? 'block' : 'none';
}
document.getElementById('shapeSel').addEventListener('change', () => {
  syncBaseVisibility();
  generateTaskFromUI();
});
document.getElementById('baseSel').addEventListener('change', generateTaskFromUI);
document.getElementById('typeSel').addEventListener('change', generateTaskFromUI);
document.getElementById('difficultySel').addEventListener('change', generateTaskFromUI);
document.getElementById('noQuadratic').addEventListener('change', generateTaskFromUI);
document.getElementById('strictFormula').addEventListener('change', generateTaskFromUI);

document.getElementById('newTaskBtn').addEventListener('click', generateTaskFromUI);
document.getElementById('regenBtn').addEventListener('click', generateTaskFromUI);
document.getElementById('checkBtn').addEventListener('click', checkAnswer);
document.getElementById('ansInput').addEventListener('keydown', (e) => {
  if(e.key === 'Enter') checkAnswer();
});

// IMPORTANT: Musterlösung per Details (funktioniert zuverlässig)
// zusätzlicher Button toggelt details.open
document.getElementById('showSolBtn').addEventListener('click', () => {
  const d = document.getElementById('solutionDetails');
  d.open = !d.open;
});

/* =========================
   Init
========================= */
syncBaseVisibility();
generateTaskFromUI();
</script>
</body>
</html>
